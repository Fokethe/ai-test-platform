---
name: tdd-loop
description: TDD (Test-Driven Development) iterative development loop. Automatically cycles through red-green-refactor phases with self-testing and auto-fix until all tests pass. Supports continuous iteration for multi-feature development.
---

# TDD 循环开发模式

自动化的测试驱动开发循环，支持红-绿-重构的完整流程，自动测试、自动修复、自动进入下一轮，直到功能完成。

## 核心循环

```
┌─────────────────────────────────────────────────────────────────┐
│  第 N 轮迭代                                                     │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐         │
│  │  1. 分析需求  │ → │  2. 编写测试  │ → │  3. 运行测试  │         │
│  │  (理解任务)   │    │  (红阶段)    │    │  (验证红)    │         │
│  └─────────────┘    └─────────────┘    └──────┬──────┘         │
│                                                ↓ 通过            │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐         │
│  │  6. 下一轮   │ ← │  5. 重构代码  │ ← │  4. 编写实现  │         │
│  │  (新功能)    │    │  (优化)      │    │  (绿阶段)    │         │
│  └─────────────┘    └─────────────┘    └─────────────┘         │
│       ↑__________________________________________|             │
└─────────────────────────────────────────────────────────────────┘
                              ↓ 测试失败
                    ┌─────────────────────┐
                    │  自动修复循环 (子循环)  │
                    │  分析失败 → 修复代码    │
                    │  → 重跑测试 → 通过?     │
                    │  (最多 3 次修复尝试)    │
                    └─────────────────────┘
```

## 触发方式

**主触发词**：
- "TDD 模式"
- "循环开发"
- "自动测试开发"
- "迭代开发"
- "红绿重构"
- "先写测试"

**快捷指令**：
- `/tdd` - 进入 TDD 模式，开始新一轮循环
- `/tdd next` - 当前功能完成，进入下一个功能
- `/tdd fix` - 手动触发修复当前失败测试
- `/tdd stop` - 停止 TDD 循环

## 执行流程详解

### Phase 1: 需求分析与测试设计（红阶段准备）

```
【输入】功能需求描述
【输出】
📋 功能分析: {功能名}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
功能点:
  1. {功能点1} - 输入: {input}, 预期输出: {output}
  2. {功能点2} - 输入: {input}, 预期输出: {output}
  3. ...

测试策略:
  - 单元测试: {测试范围}
  - 边界条件: {边界情况}
  - 异常处理: {异常情况}

预估: {n} 个测试用例, 预计 {m} 轮迭代
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

**用户确认后**进入 Phase 2

---

### Phase 2: 编写测试（红阶段）

```
【动作】仅编写测试代码，不实现功能
【输出】
🔴 红阶段: 编写测试
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
文件: {test-file-path}

测试用例 1: {测试名}
  describe('{功能名}', () => {
    it('{测试描述}', () => {
      // Arrange
      const input = { ... };
      
      // Act
      const result = targetFunction(input);
      
      // Assert
      expect(result).toBe(expected);
    });
  });

运行测试...
❌ 测试失败 (预期): {错误信息}
✓ 红阶段完成，可以开始实现
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

**规则**：
- 只写测试，不写实现
- 确保测试能运行且失败（验证测试有效性）
- 测试失败后停止，等待确认

---

### Phase 3: 编写最小实现（绿阶段）

```
【动作】编写最小代码使测试通过
【输出】
🟢 绿阶段: 最小实现
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
文件: {implementation-file-path}

export function targetFunction(input) {
  // 最小实现，仅通过当前测试
  return { ... };
}

运行测试...
✅ 全部通过 (1/1)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

**规则**：
- 只求通过，不求完美
- 如有多个测试，逐个使它们通过
- 如有测试失败，进入修复子循环

---

### Phase 4: 自动修复子循环（失败时）

当测试失败时，自动进入修复循环（最多 3 次）：

```
🔄 自动修复模式 (尝试 1/3)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
失败测试: {测试名}
错误信息: {error}

分析:
  - 失败类型: {TypeError / AssertionError / etc}
  - 可能原因: {原因分析}

修复方案:
  {代码修改 diff}

运行测试...
✅ 修复成功 / ❌ 仍失败，继续修复...
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

**退出条件**：
- ✅ 测试通过 → 继续 Phase 5
- ❌ 3 次修复失败 → 暂停，请求人工介入

---

### Phase 5: 重构（可选）

```
【动作】改进代码质量，保持测试通过
【输出】
🔧 重构阶段
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
重构点:
  1. 提取函数: {提取说明}
  2. 重命名: {重命名说明}
  3. 简化逻辑: {简化说明}

运行测试...
✅ 重构后测试仍通过
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

**规则**：
- 小步重构，每次重构后运行测试
- 如果测试失败，回滚重构
- 询问用户是否重构（可配置自动跳过）

---

### Phase 6: 迭代决策

```
🎯 第 {n} 轮完成
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
完成功能: {功能名}
测试覆盖: {n} 个测试
代码行数: {行数}
本轮消耗: ${cost}
累计消耗: ${total}

下一步选择:
  1. 📝 继续下一功能 - 说"/tdd next" 或 "继续"
  2. 🔧 重构优化 - 说"重构"
  3. 📊 查看状态 - 说"/cost"
  4. 🛑 结束 TDD - 说"/tdd stop"
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

## 完整执行示例

### 示例：开发一个计算器功能

```
用户: TDD 模式，实现一个计算器，支持加减乘除

AI: [进入 TDD 模式 - Phase 1]
    📋 功能分析: 计算器
    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    功能点:
      1. 加法 - 输入: (a, b), 预期: a+b
      2. 减法 - 输入: (a, b), 预期: a-b
      3. 乘法 - 输入: (a, b), 预期: a*b
      4. 除法 - 输入: (a, b), 预期: a/b, 边界: b≠0
    
    测试策略: 每个功能 3 个测试用例（正常+边界+异常）
    预估: 12 个测试用例, 预计 4 轮迭代
    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    
    开始第一轮？[Y/N]

用户: Y

AI: [Phase 2 - 第一轮: 加法功能]
    🔴 红阶段: 编写加法测试
    文件: calculator.test.ts
    
    describe('Calculator', () => {
      describe('add', () => {
        it('should add two positive numbers', () => {
          expect(add(2, 3)).toBe(5);
        });
        it('should handle negative numbers', () => {
          expect(add(-2, 3)).toBe(1);
        });
        it('should handle zero', () => {
          expect(add(0, 5)).toBe(5);
        });
      });
    });
    
    运行测试...
    ❌ ReferenceError: add is not defined
    ✓ 红阶段完成
    
    [Phase 3 - 绿阶段]
    🟢 绿阶段: 实现 add 函数
    文件: calculator.ts
    
    export function add(a: number, b: number): number {
      return a + b;
    }
    
    运行测试...
    ✅ 全部通过 (3/3)
    
    [Phase 4 - 重构]
    🔧 重构: 无需重构，代码已简洁
    
    [Phase 5 - 迭代决策]
    🎯 第 1 轮完成 (加法功能)
    下一步? /tdd next / 重构 / /cost / /tdd stop

用户: /tdd next

AI: [Phase 2 - 第二轮: 减法功能]
    🔴 红阶段: 编写减法测试...
    ...
```

---

## 配置选项

可以在项目 `KIMI.md` 中配置 TDD 模式：

```markdown
## TDD Loop 配置

```yaml
tdd:
  # 测试框架
  test_framework: jest  # jest | vitest | mocha | pytest | etc
  
  # 测试文件模式
  test_pattern: "**/*.test.ts"
  
  # 自动修复尝试次数
  max_fix_attempts: 3
  
  # 是否自动重构
  auto_refactor: false  # true | false | ask
  
  # 重构阈值（测试通过后自动重构）
  refactor_threshold: 3  # 第 n 轮后询问重构
  
  # 单轮最大消耗
  max_cost_per_round: 0.05
  
  # 是否并行运行测试
  parallel: false
  
  # 测试覆盖率要求
  coverage:
    enabled: true
    threshold: 80  # 最低覆盖率 %
```
```

---

## 状态追踪

TDD 循环会在 `progress.txt` 中记录状态：

```markdown
## TDD 开发状态

当前模式: TDD Loop
功能: 计算器
进度: 2/4 功能完成

- [x] 加法功能 (3 tests)
- [x] 减法功能 (3 tests)
- [ ] 乘法功能 (pending)
- [ ] 除法功能 (pending)

累计轮次: 2
累计测试: 6 passed, 0 failed
累计消耗: $0.08
```

---

## 与其他 Skill 的协作

```
用户输入 "TDD 模式开发新功能"
    ↓
skill-orchestrator 识别意图
    ↓
cost-control (建立基线)
    ↓
tdd-loop (主循环)
    ├── task-planner (每轮需求分析)
    ├── code-review (重构阶段)
    ├── debug-diagnosis (修复失败时)
    ├── danger-signals (检测无限循环)
    └── doc-system (更新 progress.txt)
    ↓
cost-control (总结消耗)
```

---

## 打断与干预

在循环过程中，用户可以随时：

| 指令 | 作用 |
|-----|------|
| `跳过` | 跳过当前阶段，进入下一阶段 |
| `跳过测试` | 跳过当前测试，进入下一个测试 |
| `回退` | 回退到上一轮 |
| `重构` | 立即进入重构阶段 |
| `不重构` | 跳过重构，进入下一轮 |
| `修改测试` | 回到 Phase 2 修改测试 |
| `/cost` | 查看当前消耗（不中断循环）|
| `/tdd stop` | 完全停止 TDD 模式 |

---

## 最佳实践

### 1. 功能粒度
- 每轮只实现 **一个最小功能点**
- 避免一轮实现多个复杂功能
- 如果功能复杂，先用 task-planner 拆分

### 2. 测试设计
- 遵循 **FIRST** 原则：
  - **F**ast: 测试要快
  - **I**ndependent: 测试独立
  - **R**epeatable: 可重复运行
  - **S**elf-validating: 自我验证（布尔结果）
  - **T**imely: 及时编写（TDD）

### 3. 红绿比例
- 红阶段：1-3 个测试（不要一次写太多）
- 绿阶段：最小实现（不要过度设计）
- 重构阶段：小步前进（频繁运行测试）

### 4. 成本控制
- 每轮后自动显示 `/cost`
- 单轮 > $0.05 时暂停询问
- 累计 > $0.30 时建议结束当前会话
