# Cline 智能助手规则配置
# 版本: 1.1 | 适用: ai-test-platform 项目

================================================================================
## Skill 0: Skill 编排器 (Skill Orchestrator) - 意图识别
================================================================================
【触发方式】: 每轮对话优先执行，自动识别用户意图并触发 Skill 序列

【意图识别规则】:
当用户输入以下关键词时，自动执行对应的 Skill 序列（无需手动输入 /skill:xxx）:

| 用户意图 | 触发关键词 | 自动执行的 Skill 序列 |
|---------|-----------|---------------------|
| 新项目启动 | "开始新项目" "新项目" "从零开始" | cost-control → socratic-inquiry → task-planner → doc-system → workflow |
| 功能开发 | "开发新功能" "添加功能" "实现功能" "做功能" | cost-control → task-planner → workflow → code-review → doc-system → cost-control |
| **TDD 循环** | **"TDD 模式"** **"循环开发"** **"迭代开发"** **"先写测试"** **"红绿重构"** | **cost-control → tdd-loop (红→绿→重构→自动下一轮)** |
| 代码重构 | "重构" "优化代码" "代码重构" "重构代码" | cost-control → code-review → task-planner → code-refactor → code-review → doc-system → git-commit → cost-control |
| Bug 修复 | "修复bug" "debug" "报错了" "出错了" "报错" | cost-control → debug-diagnosis → danger-signals → code-review → doc-system → git-commit → cost-control |
| 设计还原 | "还原设计" "设计稿" "截图转代码" "实现设计" | cost-control → visual-coding → task-planner → workflow → code-review → doc-system → git-commit → cost-control |
| 文档整理 | "整理文档" "处理文档" "文档太大" "大文档" | cost-control → doc-processor → 逐块处理 → 整合 → cost-control |
| 代码提交 | "提交代码" "commit" "怎么提交" "写commit" | cost-control → code-review → project-context → doc-system → git-commit → cost-control |
| 健康检查 | "检查健康" "总结进度" "防止失忆" "检查状态" | cost-control → context-management → danger-signals → doc-system → cost-control |
| 快捷指令 | "/cost" "查消耗" "用了多少" | cost-control |
| 快捷指令 | "/compact" "压缩" "压缩上下文" | context-management |
| 快捷指令 | "/tdd" "TDD" "tdd 模式" | tdd-loop |
| 快捷指令 | "/tdd next" "下一轮" "继续 TDD" | tdd-loop (continue) |
| 快捷指令 | "review" "审查代码" "看看代码" | code-review |
| 快捷指令 | "规划" "plan" "制定计划" | task-planner |

【执行流程】:
1. **意图匹配**: 首先检查用户输入是否匹配上表关键词
2. **序列执行**: 如果匹配，按表中顺序依次执行对应的 Skills
3. **上下文传递**: 每个 Skill 完成后保留关键信息供下一个 Skill 使用
4. **用户确认点**: Plan Mode 完成后、每批修改后、消耗超阈值时询问用户
5. **单 Skill 模式**: 如果用户明确说 "/skill:xxx" 或提及具体单个 Skill 名称，优先执行单个 Skill
6. **循环模式**: TDD 模式下，红-绿-重构完成后自动询问是否下一轮

【特殊模式 - TDD Loop】:
当匹配 TDD 关键词时，进入循环开发模式:
- 红阶段: 写测试 → 运行（应失败）
- 绿阶段: 最小实现 → 运行（应通过）
- 重构: 优化代码 → 运行（仍通过）
- 下一轮: 询问用户是否继续，或说 "/tdd next"
- 自动修复: 测试失败时自动尝试修复（最多3次）

【打断与跳过】:
- 用户说"跳过" → 跳过当前 Skill/阶段，继续下一个
- 用户说"停止" → 终止整个序列
- 用户说"返回" → 回到上一个 Skill/阶段重新执行
- 用户说"/tdd stop" → 退出 TDD 循环模式

================================================================================
## Skill 1: 成本控制协议 (Cost Control)
================================================================================
【触发方式】: 每轮对话自动执行，无需用户触发；用户说 "/cost" 立即触发

【规则】:
- 读取文件 > 5,000 字符时: "📊 读取此文件预估消耗: ${cost} (约 {n} tokens)"
- 批量修改 > 3 个文件时: "⚠️ 批量修改预估消耗: ${cost}，建议分批处理"
- 单轮累计 > $0.05 时: 必须询问 "预估消耗 ${cost}，是否继续? [Y/N]"
- 单轮累计 > $0.10 时: 提示 "💡 建议开启新对话或执行 /compact 压缩上下文"

================================================================================
## Skill 2: 大文档分段处理协议 (Doc Processor)
================================================================================
【触发方式】: 检测到引用文件字符数 > 30,000 时自动激活，或用户说"整理文档"、"处理大文件"

【执行流程】:
1. **立即停止**: "检测到大型文档 (约 {n} 字符)，触发分段协议"
2. **结构分析**: 输出文档地图，建议分为 {x} 段 (每段 5,000-8,000 字符)
3. **制定计划**: 
分块方案:
 
块1: [章节范围] - 约 {n} 字 - 主题: {topic}
 
块2: [章节范围] - 约 {n} 字 - 主题: {topic}  ...
4. **逐块处理**: 等待用户发送第 1 块，处理完再要第 2 块，禁止主动读取全文
5. **最终整合**: 所有块完成后输出合并方案和去重结果

【禁止事项】:
- 禁止一次性读取 > 5 万字
- 禁止未制定分块计划前直接回答内容摘要

================================================================================
## Skill 3: 代码重构协议 (Code Refactor)
================================================================================
【触发方式】: 用户输入"重构"、"优化代码"、"重构 {文件名}"、"整理项目结构"

【执行策略】:
1. **依赖分析**: 使用 Read/Glob 分析文件关系，识别底层工具 (utils) → 业务逻辑 (services) → UI 层 (components)
2. **分批修改**: 每次最多处理 3 个紧密关联的文件
3. **安全原则**:
- 保持函数签名向后兼容
- 修改前输出 diff 对比
- 建议用户先 `git add .` 再应用修改
4. **输出格式**:
🔧 重构计划: {模块名}  ├── 文件1: {文件名} - 修改点: {简述}  ├── 文件2: {文件名} - 修改点: {简述}  └── 依赖检查: {是否影响其他文件}
[diff 对比]
【约束】:
- 禁止自动执行 rm/drop 等危险命令
- 修改后必须询问 "是否应用这些修改?"

================================================================================
## Skill 4: 任务拆解与规划协议 (Task Planner)
================================================================================
【触发方式】: 用户提出复杂需求含"实现"、"开发"、"做个系统"、"添加功能"、"从零开始"等关键词，且需求涉及多步骤时

【强制步骤】:
1. **暂停编码**: 不要立即写代码
2. **输出计划**:
📋 执行计划: {任务名}  预估总消耗: ${cost} | 预计 {n} 轮对话
阶段 1: 准备与调研
 
分析现有代码结构
 
识别依赖关系
阶段 2: 实施
 
{步骤1} → 产出: {文件}
 
{步骤2} → 产出: {文件}
阶段 3: 验证
 
运行测试/检查错误
3. **等待确认**: "是否按此计划执行? 或有调整?"
4. **分阶段执行**: 每完成一个阶段输出进度，询问 "继续下一阶段?"

================================================================================
## Skill 5: 代码审查协议 (Code Review)
================================================================================
【触发方式】: 用户说"审查代码"、"review"、"检查这段代码"、"看看有什么问题"

【检查清单】:
- [ ] **可读性**: 变量名语义化? 函数长度 < 50 行?
- [ ] **重复代码**: 是否有可提取的公共逻辑?
- [ ] **错误处理**: 异步错误、空值、边界情况是否处理?
- [ ] **性能**: 是否有循环嵌套、重复计算?
- [ ] **安全**: SQL 注入、XSS、敏感信息硬编码?
- [ ] **类型安全**: TypeScript 是否有 any 类型滥用?

【输出格式】:
🔍 审查结果: {文件名} 风险等级: 🔴 高 / 🟡 中 / 🟢 低
主要问题:
1. 
[问题] - 建议: [具体修改]
2. 
...
优化建议:
 
建议提取函数: {函数名} (重复出现在第 X,Y 行)
 
建议重命名: {旧} → {新}
✅ 可保留部分: {写得好的地方}

================================================================================
## Skill 6: Git 提交规范 (Commit Convention)
================================================================================
【触发方式】: 用户说"生成提交信息"、"写 commit"、"commit message"、"这次改动怎么提交"

【格式模板】:
(): 
<body>
<footer>
```
【Type 定义】:
 
 feat : 新功能
 
 fix : Bug 修复
 
 docs : 文档更新
 
 style : 代码格式 (不影响功能)
 
 refactor : 重构
 
 test : 测试相关
 
 chore : 构建/工具变动
【规则】:
1. 
subject ≤ 50 字符，使用祈使句 ("添加" 而非 "添加了")
2. 
body 说明改动原因和对比
3. 
破坏性变更标注  BREAKING CHANGE: 
【示例输出】:
feat(auth): 添加 JWT token 刷新机制

- 添加 token 过期自动刷新逻辑
- 在 axios 拦截器中处理 401 错误
- 添加刷新队列避免重复请求

解决了用户长时间操作后需要重新登录的问题
================================================================================
## Skill 7: 项目知识库上下文 (Project Context)
【触发方式】: 用户提及"根据规范"、"按项目风格"、"文档里说的"，或需要了解项目结构时自动引用
【项目结构】:
 
 docs/ : 文档目录 (PRD, API 规范, 测试用例)
 
 src/ : 源码，按功能域组织 (feature-based)
 
 docs/API/ : API 接口定义
 
 src/components/common/ : 通用组件库
 
 src/utils/ : 工具函数 (纯函数，禁止副作用)
【技术栈约束】:
 
前端: Vue 3 + TypeScript + Pinia (禁止 Options API)
 
后端: Node.js + Express + Prisma
 
测试: Vitest + Testing Library
 
代码风格: 单引号，无分号，2 空格缩进
【强制规范】:
 
禁止组件中直接调用 axios，必须使用封装后的  request.ts 
 
禁止硬编码 API URL，使用环境变量
 
禁止使用  any  类型，必须用具体类型或  unknown 
【优先级引用】: 当用户提及规范时，优先读取:  docs/GUIDE.md  >  docs/API/README.md  > 本规则
================================================================================
## 系统指令 (System Instructions)
【全局约束】:
1. 
回复使用中文，技术术语保留英文 (如 API, Token, diff)
2. 
每轮回复必须包含 Token 成本预估 (Skill 1 要求)
3. 
遇到冲突规则时，优先级: Cost Control > Doc Processor > 其他
4. 
上下文占用 > 60% 时主动提示: "💡 上下文即将满载，建议开新对话"
【快捷指令支持】:
 
用户输入  /next : 继续下一阶段/下一块内容
 
用户输入  /plan : 重新生成分段/任务计划
 
用户输入  /cost : 显示当前累计消耗

## Skill 8: 需求审问协议 (Socratic Inquiry)
【触发方式】: 用户说"新项目启动"、"开始新项目"、"我要做..."、需求模糊时

【执行流程】:
1. **暂停编码**: 不要立即写代码
2. **苏格拉底式提问**:
   - 每次只问 1 个最关键的问题
   - 从"用户打开应用第一眼看到什么"开始
   - 根据回答深入追问细节
   - 直到需求完全清晰，没有歧义
3. **输出澄清文档**: 整理确认后的需求要点

【审问问题库】:
- 用户第一眼看到什么？第一步操作什么？
- 核心功能有哪些？优先级排序？
- 数据存储在哪里？本地还是云端？
- 目标用户是谁？使用场景是什么？
- 需要哪些字段？有什么业务规则？

【约束】:
- 审问至少 5-8 轮
- 禁止在需求清晰前生成代码
- 用中文提问，保持自然对话

## Skill 9: 文档双轨系统 (Doc System)
【触发方式】: 新项目初始化时自动创建，或用户说"创建项目文档"、"初始化文档"

【双文档结构】:
1. **KIMI.md** (AI 操作手册)
   - 位置: 项目根目录
   - 内容: 技术栈、文件路径约定、技术铁律、当前目标
   - 更新: 每次会话前读取，目标变更时更新

2. **progress.md** (进度追踪)
   - 位置: 项目根目录
   - 内容: 已完成、当前进行、下一步、技术债务
   - 更新: 每完成一个功能后更新

【模板内容】:
```markdown
# KIMI.md 模板
# Project: [名称]
# Stack: [技术栈]

## 技术铁律
- [具体约束，如禁止 any 类型]

## 文件路径约定
- 页面: src/app/[route]/page.tsx
- 组件: src/components/[Name]/index.tsx

## 当前目标
[每次会话前更新]

## 已完成
[AI 自动更新]
```

【约束】:
- 新项目必须创建这两个文档
- 每次会话开场必须读取它们
- 禁止在文档缺失时开始复杂开发

## Skill 10: 四步工作流 (Workflow)
【触发方式】: 项目开发过程中自动遵循，或用户说"开始开发"、"进入工作流"

【四步标准流程】:

**Step 1: 审问 (5-10 分钟)**
- 目标: 把模糊想法变成具体需求
- 方法: 苏格拉底式提问（见 Skill 8）
- 产出: 澄清后的需求文档

**Step 2: 拆解 (文档化)**
- 目标: 生成可执行的开发清单
- 产出: 
  - PRD（产品需求）: 功能列表、用户故事、验收标准
  - 技术方案: 数据模型、API 列表、页面路由
  - 实施计划: 按依赖顺序排列的 5-8 个步骤

**Step 3: 实现 (迭代循环)**
- 目标: 小步快跑，一次一个功能
- 会话开场白模板:
  ```
  读取 KIMI.md 和 progress.txt。
  本次目标: [具体功能]
  约束:
  - 严格按照 plan.md 第 X 步
  - 先写 TypeScript 类型定义
  - 再写组件逻辑
  - 最后写样式
  - 每完成一部分让我确认
  ```

**Step 4: 验收 (Checklist)**
- 目标: 确保质量，更新进度
- 检查项:
  1. 代码审查: 检查 Bug、类型错误、性能问题
  2. 规范检查: 是否符合 KIMI.md 技术铁律
  3. 功能验证: 列出 3 个测试用例
  4. 更新 progress.txt: 标记完成，记录问题

【约束】:
- 禁止跳过任何步骤
- 每步完成后明确确认再进入下一步
- 中途偏离时回到当前步骤

## Skill 11: 视觉还原协议 (Visual Coding)
【触发方式】: 用户上传图片/截图后说"还原这个界面"、"实现这个设计"、"截图转代码"

【执行流程】:
1. **结构分析**: 先输出"这是什么页面，有哪些模块"
2. **像素级还原**:
   - 配色: 精确匹配截图中的颜色
   - 间距: 使用 Tailwind 标准间距 scale
   - 字体: 匹配字体大小和字重
   - 圆角: 匹配 border-radius
3. **布局实现**:
   - 使用 Flex/Grid
   - 禁止绝对定位（除非是悬浮按钮）
4. **响应式推导**:
   - 如果是桌面端截图，自动推导移动端布局
   - 说明折叠/堆叠策略
5. **交互状态**:
   - 所有按钮添加 hover/active 状态
6. **组件化**:
   - 拆分为 Header/Content/Sidebar 等逻辑组件

【输出格式】:
```
📐 结构分析:
- 页面类型: [如仪表盘]
- 主要模块: [模块列表]

🎨 设计规范提取:
- 主色: [色值]
- 间距系统: [如 16px 基准]
- 字体: [大小层级]

💻 代码实现:
[组件代码]
```

【约束】:
- 先分析后编码
- 不确定的地方询问确认
- 复杂界面分组件输出

## Skill 12: 调试诊断协议 (Debug Diagnosis)
【触发方式】: 用户粘贴错误信息时说"修复这个错误"、"分析原因"、"运行报错"

【万能公式模板】:
用户需要提供:
1. 问题描述: [一句话描述现象]
2. 错误信息: ```[完整报错，包括堆栈]```
3. 相关代码: ```[相关代码片段]```
4. 预期行为: [应该发生什么]
5. 实际行为: [实际发生什么]

【分析步骤】:
1. **根本原因分析**: 错误产生的根本原因是什么？
2. **修复方案**: 有哪些修复方案？推荐哪个？
3. **修复代码**: 给出修复后的完整代码
4. **预防措施**: 如何预防类似问题？

【输出格式】:
```
🔍 错误分析:
- 错误类型: [如 TypeError]
- 根本原因: [解释]
- 发生位置: [文件:行号]

💡 修复方案:
推荐: [方案描述]
替代: [其他方案]

📝 修复代码:
```diff
[diff 对比]
```

🛡️ 预防建议:
- [建议1]
- [建议2]
```

【约束】:
- 不猜测，基于提供的代码和错误分析
- 给出具体行号引用
- 提供多种修复方案供选择

## Skill 13: 危险信号检测 (Danger Signals)
【触发方式】: 开发过程中自动监控，检测到危险信号时立即提醒

【危险信号清单】:
- [ ] **AI 开始重复之前的内容** → 上下文满了，必须新建会话
- [ ] **生成的代码无法运行，修复 3 次还没好** → 回滚到上一个稳定版本，重新描述需求
- [ ] **AI 说"根据常见做法..."** → 描述太模糊，必须进入审问模式（Skill 8）
- [ ] **一次生成了 5 个以上文件** → 粒度太粗，要求"一次只生成一个组件"
- [ ] **代码中出现大量 any 或 @ts-ignore** → 要求"严格类型，禁止 any"
- [ ] **单轮累计消耗 > $0.05** → 询问是否继续（Skill 1）
- [ ] **上下文占用 > 60%** → 提示开新对话

【应对措施】:
```
🚨 危险信号检测: [信号描述]

建议行动:
1. [具体行动1]
2. [具体行动2]

是否执行? [Y/N]
```

【约束】:
- 检测到危险信号必须立即停止当前操作
- 不允许忽视危险信号继续编码
- 必须得到用户确认后再继续

## Skill 14: 上下文管理协议 (Context Management)
【触发方式】: 自动执行，或用户说"总结进度"、"更新 progress"、"防止失忆"

【管理策略】:
1. **每 10-15 轮对话**: 
   - 说"总结当前进度，更新 progress.txt"
   - 输出当前状态摘要
   
2. **切换功能时**:
   - 新建会话
   - 粘贴 KIMI.md + progress.txt 作为开场
   
3. **代码过长时**:
   - 说"只展示修改的部分，用 diff 格式"
   - 避免重复输出未变更代码

4. **会话开场标准模板**:
   ```
   读取 KIMI.md 和 progress.txt。
   
   今日目标: [具体功能]
   
   开发前确认:
   1. 这个功能依赖哪些已完成的部分？
   2. 是否需要新建文件？路径是什么？
   3. 潜在的技术难点是什么？
   
   确认后，开始第一步: [具体步骤]
   ```

【上下文压缩技巧】:
- 使用 diff 格式展示修改
- 引用文件用 @filename 而非粘贴内容
- 复杂逻辑先给大纲，确认后再给细节

【约束】:
- 上下文占用 > 60% 时必须主动提示
- 禁止在上下文满载时继续复杂操作
- 优先使用外部文档存储状态

---

## 使用说明

**保存位置**: 项目根目录 `ai-test-platform/.clinerules`

**立即测试**:
1. 保存文件后，**重启 Cline 对话**（点 + 号新建）
2. 引用你的大文件：`@Kimi_Code_Vibe_Coding_Guide.md 帮我整理`
3. 应该触发 **Skill 2**，显示分段提示而不是直接读取
4. 说"我要做一个新项目"应该触发 **Skill 8** 进入审问模式

**后续调整**:
- 如果某个 Skill 太敏感（频繁误触发），修改其【触发方式】描述，加更多关键词限制
- 如果规则太长导致 Cline 加载慢，可以删掉暂不需要的 Skill（如暂时不用 Skill 5 代码审查）
- 建议保留的核心 Skill: 1, 2, 8, 10, 12, 13
