# Cline 智能助手规则配置
# 版本: 1.1 | 适用: ai-test-platform 项目

================================================================================
## Skill 0: Skill 编排器 (Skill Orchestrator) - 意图识别
================================================================================
【触发方式】: 每轮对话优先执行，自动识别用户意图并触发 Skill 序列

【意图识别规则】:
当用户输入以下关键词时，自动执行对应的 Skill 序列（无需手动输入 /skill:xxx）:

| 用户意图 | 触发关键词 | 自动执行的 Skill 序列 |
|---------|-----------|---------------------|
| 新项目启动 | "开始新项目" "新项目" "从零开始" | cost-control → socratic-inquiry → task-planner → doc-system → workflow |
| 功能开发 | "开发新功能" "添加功能" "实现功能" "做功能" | cost-control → task-planner → workflow → code-review → doc-system → cost-control |
| **TDD 循环** | **"TDD 模式"** **"循环开发"** **"迭代开发"** **"先写测试"** **"红绿重构"** | **cost-control → tdd-dev → tdd-loop (红→绿→重构→自动下一轮)** |
| 代码重构 | "重构" "优化代码" "代码重构" "重构代码" "优化这段代码" | cost-control → code-review → task-planner → code-refactor → code-review → doc-system → git-commit → cost-control |
| Bug 修复 | "修复bug" "debug" "报错了" "出错了" "报错" "修复 Bug" "修复问题" | cost-control → debug-diagnosis → danger-signals → code-review → doc-system → git-commit → cost-control |
| 设计还原 | "还原设计" "设计稿" "截图转代码" "实现设计" | cost-control → visual-coding → task-planner → workflow → code-review → doc-system → git-commit → cost-control |
| 文档整理 | "整理文档" "处理文档" "文档太大" "大文档" | cost-control → doc-processor → 逐块处理 → 整合 → cost-control |
| 代码提交 | "提交代码" "commit" "怎么提交" "写commit" | cost-control → code-review → project-context → doc-system → git-commit → cost-control |
| 健康检查 | "检查健康" "检查健康度" "总结进度" "防止失忆" "检查状态" "状态检查" | cost-control → context-management → danger-signals → code-review → doc-system → cost-control |
| 快捷指令 | "/cost" "查消耗" "用了多少" | cost-control |
| 快捷指令 | "/compact" "压缩" "压缩上下文" | context-management |
| 快捷指令 | "/tdd" "TDD" "tdd 模式" | tdd-loop |
| 快捷指令 | "/tdd next" "下一轮" "继续 TDD" | tdd-loop (continue) |
| 快捷指令 | "review" "审查代码" "看看代码" | code-review |
| 快捷指令 | "规划" "plan" "制定计划" "任务规划" | task-planner |
| 快捷指令 | "/tdd" "TDD" "tdd 模式" | tdd-dev |
| 快捷指令 | "/tdd next" "下一轮" "继续 TDD" | tdd-loop (continue) |
| 快捷指令 | "/brainstorm" "脑爆" "头脑风暴" | brainstorm |
| 快捷指令 | "/write-plan" "写计划" "生成计划" | write-plan |
| 快捷指令 | "/execute-plan" "执行计划" "按计划执行" | execute-plan |

【执行流程】:
1. **意图匹配**: 首先检查用户输入是否匹配上表关键词
2. **序列执行**: 如果匹配，按表中顺序依次执行对应的 Skills
3. **上下文传递**: 每个 Skill 完成后保留关键信息供下一个 Skill 使用
4. **用户确认点**: Plan Mode 完成后、每批修改后、消耗超阈值时询问用户
5. **单 Skill 模式**: 如果用户明确说 "/skill:xxx" 或提及具体单个 Skill 名称，优先执行单个 Skill
6. **循环模式**: TDD 模式下，红-绿-重构完成后自动询问是否下一轮

【特殊模式 - TDD Loop】:
当匹配 TDD 关键词时，进入循环开发模式:
- 红阶段: 写测试 → 运行（应失败）
- 绿阶段: 最小实现 → 运行（应通过）
- 重构: 优化代码 → 运行（仍通过）
- 下一轮: 询问用户是否继续，或说 "/tdd next"
- 自动修复: 测试失败时自动尝试修复（最多3次）

【打断与跳过】:
- 用户说"跳过" → 跳过当前 Skill/阶段，继续下一个
- 用户说"停止" → 终止整个序列
- 用户说"返回" → 回到上一个 Skill/阶段重新执行
- 用户说"/tdd stop" → 退出 TDD 循环模式

================================================================================
## Skill 1: 成本控制协议 (Cost Control)
================================================================================
【触发方式】: 每轮对话自动执行，无需用户触发；用户说 "/cost" 立即触发

【规则】:
- 读取文件 > 5,000 字符时: "📊 读取此文件预估消耗: ${cost} (约 {n} tokens)"
- 批量修改 > 3 个文件时: "⚠️ 批量修改预估消耗: ${cost}，建议分批处理"
- 单轮累计 > $0.05 时: 必须询问 "预估消耗 ${cost}，是否继续? [Y/N]"
- 单轮累计 > $0.10 时: 提示 "💡 建议开启新对话或执行 /compact 压缩上下文"

================================================================================
## Skill 2: 大文档分段处理协议 (Doc Processor)
================================================================================
【触发方式】: 检测到引用文件字符数 > 30,000 时自动激活，或用户说"整理文档"、"处理大文件"

【执行流程】:
1. **立即停止**: "检测到大型文档 (约 {n} 字符)，触发分段协议"
2. **结构分析**: 输出文档地图，建议分为 {x} 段 (每段 5,000-8,000 字符)
3. **制定计划**: 
分块方案:
 
块1: [章节范围] - 约 {n} 字 - 主题: {topic}
 
块2: [章节范围] - 约 {n} 字 - 主题: {topic}  ...
4. **逐块处理**: 等待用户发送第 1 块，处理完再要第 2 块，禁止主动读取全文
5. **最终整合**: 所有块完成后输出合并方案和去重结果

【禁止事项】:
- 禁止一次性读取 > 5 万字
- 禁止未制定分块计划前直接回答内容摘要

================================================================================
## Skill 3: 代码重构协议 (Code Refactor)
================================================================================
【触发方式】: 用户输入"重构"、"优化代码"、"重构 {文件名}"、"整理项目结构"

【执行策略】:
1. **依赖分析**: 使用 Read/Glob 分析文件关系，识别底层工具 (utils) → 业务逻辑 (services) → UI 层 (components)
2. **分批修改**: 每次最多处理 3 个紧密关联的文件
3. **安全原则**:
- 保持函数签名向后兼容
- 修改前输出 diff 对比
- 建议用户先 `git add .` 再应用修改
4. **输出格式**:
🔧 重构计划: {模块名}  ├── 文件1: {文件名} - 修改点: {简述}  ├── 文件2: {文件名} - 修改点: {简述}  └── 依赖检查: {是否影响其他文件}
[diff 对比]
【约束】:
- 禁止自动执行 rm/drop 等危险命令
- 修改后必须询问 "是否应用这些修改?"

================================================================================
## Skill 4: 任务拆解与规划协议 (Task Planner)
================================================================================
【触发方式】: 用户提出复杂需求含"实现"、"开发"、"做个系统"、"添加功能"、"从零开始"等关键词，且需求涉及多步骤时

【强制步骤】:
1. **暂停编码**: 不要立即写代码
2. **输出计划**:
📋 执行计划: {任务名}  预估总消耗: ${cost} | 预计 {n} 轮对话
阶段 1: 准备与调研
 
分析现有代码结构
 
识别依赖关系
阶段 2: 实施
 
{步骤1} → 产出: {文件}
 
{步骤2} → 产出: {文件}
阶段 3: 验证
 
运行测试/检查错误
3. **等待确认**: "是否按此计划执行? 或有调整?"
4. **分阶段执行**: 每完成一个阶段输出进度，询问 "继续下一阶段?"

================================================================================
## Skill 5: 代码审查协议 (Code Review)
================================================================================
【触发方式】: 用户说"审查代码"、"review"、"检查这段代码"、"看看有什么问题"

【检查清单】:
- [ ] **可读性**: 变量名语义化? 函数长度 < 50 行?
- [ ] **重复代码**: 是否有可提取的公共逻辑?
- [ ] **错误处理**: 异步错误、空值、边界情况是否处理?
- [ ] **性能**: 是否有循环嵌套、重复计算?
- [ ] **安全**: SQL 注入、XSS、敏感信息硬编码?
- [ ] **类型安全**: TypeScript 是否有 any 类型滥用?

【输出格式】:
🔍 审查结果: {文件名} 风险等级: 🔴 高 / 🟡 中 / 🟢 低
主要问题:
1. 
[问题] - 建议: [具体修改]
2. 
...
优化建议:
 
建议提取函数: {函数名} (重复出现在第 X,Y 行)
 
建议重命名: {旧} → {新}
✅ 可保留部分: {写得好的地方}

================================================================================
## Skill 6: Git 提交规范 (Commit Convention)
================================================================================
【触发方式】: 用户说"生成提交信息"、"写 commit"、"commit message"、"这次改动怎么提交"

【格式模板】:
(): 
<body>
<footer>
```
【Type 定义】:
 
 feat : 新功能
 
 fix : Bug 修复
 
 docs : 文档更新
 
 style : 代码格式 (不影响功能)
 
 refactor : 重构
 
 test : 测试相关
 
 chore : 构建/工具变动
【规则】:
1. 
subject ≤ 50 字符，使用祈使句 ("添加" 而非 "添加了")
2. 
body 说明改动原因和对比
3. 
破坏性变更标注  BREAKING CHANGE: 
【示例输出】:
feat(auth): 添加 JWT token 刷新机制

- 添加 token 过期自动刷新逻辑
- 在 axios 拦截器中处理 401 错误
- 添加刷新队列避免重复请求

解决了用户长时间操作后需要重新登录的问题
================================================================================
## Skill 7: 项目知识库上下文 (Project Context)
【触发方式】: 用户提及"根据规范"、"按项目风格"、"文档里说的"，或需要了解项目结构时自动引用
【项目结构】:
 
 docs/ : 文档目录 (PRD, API 规范, 测试用例)
 
 src/ : 源码，按功能域组织 (feature-based)
 
 docs/API/ : API 接口定义
 
 src/components/common/ : 通用组件库
 
 src/utils/ : 工具函数 (纯函数，禁止副作用)
【技术栈约束】:
 
前端: Vue 3 + TypeScript + Pinia (禁止 Options API)
 
后端: Node.js + Express + Prisma
 
测试: Vitest + Testing Library
 
代码风格: 单引号，无分号，2 空格缩进
【强制规范】:
 
禁止组件中直接调用 axios，必须使用封装后的  request.ts 
 
禁止硬编码 API URL，使用环境变量
 
禁止使用  any  类型，必须用具体类型或  unknown 
【优先级引用】: 当用户提及规范时，优先读取:  docs/GUIDE.md  >  docs/API/README.md  > 本规则
================================================================================
## 系统指令 (System Instructions)
【全局约束】:
1. 
回复使用中文，技术术语保留英文 (如 API, Token, diff)
2. 
每轮回复必须包含 Token 成本预估 (Skill 1 要求)
3. 
遇到冲突规则时，优先级: Cost Control > Doc Processor > 其他
4. 
上下文占用 > 60% 时主动提示: "💡 上下文即将满载，建议开新对话"
【快捷指令支持】:
 
用户输入  /next : 继续下一阶段/下一块内容
 
用户输入  /plan : 重新生成分段/任务计划
 
用户输入  /cost : 显示当前累计消耗

## Skill 8: 需求审问协议 (Socratic Inquiry)
【触发方式】: 用户说"新项目启动"、"开始新项目"、"我要做..."、需求模糊时

【执行流程】:
1. **暂停编码**: 不要立即写代码
2. **苏格拉底式提问**:
   - 每次只问 1 个最关键的问题
   - 从"用户打开应用第一眼看到什么"开始
   - 根据回答深入追问细节
   - 直到需求完全清晰，没有歧义
3. **输出澄清文档**: 整理确认后的需求要点

【审问问题库】:
- 用户第一眼看到什么？第一步操作什么？
- 核心功能有哪些？优先级排序？
- 数据存储在哪里？本地还是云端？
- 目标用户是谁？使用场景是什么？
- 需要哪些字段？有什么业务规则？

【约束】:
- 审问至少 5-8 轮
- 禁止在需求清晰前生成代码
- 用中文提问，保持自然对话

## Skill 9: 文档双轨系统 (Doc System)
【触发方式】: 新项目初始化时自动创建，或用户说"创建项目文档"、"初始化文档"

【双文档结构】:
1. **KIMI.md** (AI 操作手册)
   - 位置: 项目根目录
   - 内容: 技术栈、文件路径约定、技术铁律、当前目标
   - 更新: 每次会话前读取，目标变更时更新

2. **progress.md** (进度追踪)
   - 位置: 项目根目录
   - 内容: 已完成、当前进行、下一步、技术债务
   - 更新: 每完成一个功能后更新

【模板内容】:
```markdown
# KIMI.md 模板
# Project: [名称]
# Stack: [技术栈]

## 技术铁律
- [具体约束，如禁止 any 类型]

## 文件路径约定
- 页面: src/app/[route]/page.tsx
- 组件: src/components/[Name]/index.tsx

## 当前目标
[每次会话前更新]

## 已完成
[AI 自动更新]
```

【约束】:
- 新项目必须创建这两个文档
- 每次会话开场必须读取它们
- 禁止在文档缺失时开始复杂开发

## Skill 10: 四步工作流 (Workflow)
【触发方式】: 项目开发过程中自动遵循，或用户说"开始开发"、"进入工作流"

【四步标准流程】:

**Step 1: 审问 (5-10 分钟)**
- 目标: 把模糊想法变成具体需求
- 方法: 苏格拉底式提问（见 Skill 8）
- 产出: 澄清后的需求文档

**Step 2: 拆解 (文档化)**
- 目标: 生成可执行的开发清单
- 产出: 
  - PRD（产品需求）: 功能列表、用户故事、验收标准
  - 技术方案: 数据模型、API 列表、页面路由
  - 实施计划: 按依赖顺序排列的 5-8 个步骤

**Step 3: 实现 (迭代循环)**
- 目标: 小步快跑，一次一个功能
- 会话开场白模板:
  ```
  读取 KIMI.md 和 progress.txt。
  本次目标: [具体功能]
  约束:
  - 严格按照 plan.md 第 X 步
  - 先写 TypeScript 类型定义
  - 再写组件逻辑
  - 最后写样式
  - 每完成一部分让我确认
  ```

**Step 4: 验收 (Checklist)**
- 目标: 确保质量，更新进度
- 检查项:
  1. 代码审查: 检查 Bug、类型错误、性能问题
  2. 规范检查: 是否符合 KIMI.md 技术铁律
  3. 功能验证: 列出 3 个测试用例
  4. 更新 progress.txt: 标记完成，记录问题

【约束】:
- 禁止跳过任何步骤
- 每步完成后明确确认再进入下一步
- 中途偏离时回到当前步骤

## Skill 11: 视觉还原协议 (Visual Coding)
【触发方式】: 用户上传图片/截图后说"还原这个界面"、"实现这个设计"、"截图转代码"

【执行流程】:
1. **结构分析**: 先输出"这是什么页面，有哪些模块"
2. **设计规范提取**（四维度专业分析）:
   - **字体**: 识别字体家族、字重、行高、字间距
   - **颜色**: 提取主色、辅助色、背景色、文字色（禁止默认渐变色）
   - **动效**: 识别过渡时间、缓动函数、动画类型
   - **背景**: 分析背景类型（纯色/渐变/图片/毛玻璃）
3. **像素级还原**:
   - 配色: 精确匹配截图中的颜色，使用 Tailwind 标准色板
   - 间距: 使用 Tailwind 标准间距 scale (4px 基准)
   - 字体: 匹配字体大小和字重，使用标准字体栈
   - 圆角: 匹配 border-radius，使用标准 scale
4. **布局实现**:
   - 使用 Flex/Grid
   - 禁止绝对定位（除非是悬浮按钮）
5. **响应式推导**:
   - 如果是桌面端截图，自动推导移动端布局
   - 说明折叠/堆叠策略
6. **交互状态**:
   - 所有按钮添加 hover/active/focus 状态
   - 添加适当的过渡动画
7. **组件化**:
   - 拆分为 Header/Content/Sidebar 等逻辑组件

【设计规范标准】:
```
🎨 设计系统提取:

【字体规范】
- 主字体: [如 Inter, system-ui, sans-serif]
- 字重层级: 
  * 标题: font-bold (700)
  * 正文: font-normal (400)
  * 辅助: font-medium (500)
- 行高: leading-relaxed (1.625) / leading-tight (1.25)
- 字大小: text-xs/sm/base/lg/xl/2xl/3xl

【颜色规范】
- 主色: [如 slate-900, blue-600]
- 辅助色: [如 slate-500, blue-400]
- 背景色: [如 white, slate-50, slate-100]
- 文字色: [如 slate-900, slate-600, slate-400]
- 强调色: [如 red-500, green-500]
- ⚠️ 禁止使用默认渐变色，除非设计稿明确使用

【间距规范】
- 基础单位: 4px (Tailwind spacing-1)
- 常用间距: 4/8/12/16/24/32/48px (space-1/2/3/4/6/8/12)
- 容器最大宽度: max-w-7xl (1280px)
- 页面内边距: px-4 sm:px-6 lg:px-8

【动效规范】
- 过渡时间: duration-200 (快速) / duration-300 (标准) / duration-500 (慢速)
- 缓动函数: ease-out (默认) / ease-in-out (对称)
- 悬停效果: hover:scale-105 / hover:shadow-lg
- 焦点状态: focus:ring-2 focus:ring-blue-500

【圆角规范】
- 小元素: rounded (4px)
- 按钮/输入框: rounded-md (6px) / rounded-lg (8px)
- 卡片: rounded-xl (12px) / rounded-2xl (16px)
- 全圆: rounded-full
```

【输出格式】:
```
📐 结构分析:
- 页面类型: [如仪表盘]
- 主要模块: [模块列表]

🎨 设计规范提取:
- 主色: [色值]
- 字体: [字体栈]
- 间距系统: [如 16px 基准]
- 动效: [过渡时间/缓动函数]

💻 代码实现:
[组件代码]
```

【约束】:
- 先分析后编码
- 不确定的地方询问确认
- 复杂界面分组件输出
- 禁止使用 AI 默认渐变色风格
- 优先使用 Tailwind 标准设计 token

## Skill 12: 调试诊断协议 (Debug Diagnosis)
【触发方式】: 用户粘贴错误信息时说"修复这个错误"、"分析原因"、"运行报错"

【万能公式模板】:
用户需要提供:
1. 问题描述: [一句话描述现象]
2. 错误信息: ```[完整报错，包括堆栈]```
3. 相关代码: ```[相关代码片段]```
4. 预期行为: [应该发生什么]
5. 实际行为: [实际发生什么]

【分析步骤】:
1. **根本原因分析**: 错误产生的根本原因是什么？
2. **修复方案**: 有哪些修复方案？推荐哪个？
3. **修复代码**: 给出修复后的完整代码
4. **预防措施**: 如何预防类似问题？

【输出格式】:
```
🔍 错误分析:
- 错误类型: [如 TypeError]
- 根本原因: [解释]
- 发生位置: [文件:行号]

💡 修复方案:
推荐: [方案描述]
替代: [其他方案]

📝 修复代码:
```diff
[diff 对比]
```

🛡️ 预防建议:
- [建议1]
- [建议2]
```

【约束】:
- 不猜测，基于提供的代码和错误分析
- 给出具体行号引用
- 提供多种修复方案供选择

## Skill 13: 危险信号检测 (Danger Signals)
【触发方式】: 开发过程中自动监控，检测到危险信号时立即提醒

【危险信号清单】:
- [ ] **AI 开始重复之前的内容** → 上下文满了，必须新建会话
- [ ] **生成的代码无法运行，修复 3 次还没好** → 回滚到上一个稳定版本，重新描述需求
- [ ] **AI 说"根据常见做法..."** → 描述太模糊，必须进入审问模式（Skill 8）
- [ ] **一次生成了 5 个以上文件** → 粒度太粗，要求"一次只生成一个组件"
- [ ] **代码中出现大量 any 或 @ts-ignore** → 要求"严格类型，禁止 any"
- [ ] **单轮累计消耗 > $0.05** → 询问是否继续（Skill 1）
- [ ] **上下文占用 > 60%** → 提示开新对话

【应对措施】:
```
🚨 危险信号检测: [信号描述]

建议行动:
1. [具体行动1]
2. [具体行动2]

是否执行? [Y/N]
```

【约束】:
- 检测到危险信号必须立即停止当前操作
- 不允许忽视危险信号继续编码
- 必须得到用户确认后再继续

## Skill 14: 上下文管理协议 (Context Management)
【触发方式】: 自动执行，或用户说"总结进度"、"更新 progress"、"防止失忆"

【管理策略】:
1. **每 10-15 轮对话**: 
   - 说"总结当前进度，更新 progress.txt"
   - 输出当前状态摘要
   
2. **切换功能时**:
   - 新建会话
   - 粘贴 KIMI.md + progress.txt 作为开场
   
3. **代码过长时**:
   - 说"只展示修改的部分，用 diff 格式"
   - 避免重复输出未变更代码

4. **会话开场标准模板**:
   ```
   读取 KIMI.md 和 progress.txt。
   
   今日目标: [具体功能]
   
   开发前确认:
   1. 这个功能依赖哪些已完成的部分？
   2. 是否需要新建文件？路径是什么？
   3. 潜在的技术难点是什么？
   
   确认后，开始第一步: [具体步骤]
   ```

【上下文压缩技巧】:
- 使用 diff 格式展示修改
- 引用文件用 @filename 而非粘贴内容
- 复杂逻辑先给大纲，确认后再给细节

【约束】:
- 上下文占用 > 60% 时必须主动提示
- 禁止在上下文满载时继续复杂操作
- 优先使用外部文档存储状态

## Skill 15: 持久化规划协议 (Planning with Files)
【触发方式】: 用户说"创建任务计划"、"规划项目"、"复杂任务"、"多步骤任务"、"/plan"

【核心思想】: 复刻 Manus 的持久化规划，通过 Markdown 文件解决上下文漂移问题

【执行流程】:
1. **初始化规划文档**:
   创建 `task_plan.md`（任务计划）:
   ```markdown
   # Task Plan: [任务名称]
   Created: [时间]
   
   ## 目标
   [一句话描述任务目标]
   
   ## 执行步骤
   - [ ] 步骤 1: [描述]
   - [ ] 步骤 2: [描述]
   - [ ] 步骤 3: [描述]
   
   ## 当前状态
   当前步骤: [步骤 X]
   进度: [X/Y]
   
   ## 依赖关系
   - 步骤 2 依赖步骤 1 完成
   - 步骤 3 依赖步骤 2 完成
   ```

2. **执行与记录**:
   创建 `findings.md`（发现记录）:
   ```markdown
   # Findings: [任务名称]
   
   ## 关键发现
   - [发现 1]: [详细描述]
   - [发现 2]: [详细描述]
   
   ## 技术决策
   - [决策 1]: [原因]
   - [决策 2]: [原因]
   
   ## 遇到的问题
   - [问题 1]: [解决方案]
   ```

3. **进度追踪**:
   更新 `progress.md`（进度追踪）:
   ```markdown
   # Progress: [任务名称]
   Updated: [时间]
   
   ## 已完成
   - [x] [步骤 1]
   - [x] [步骤 2]
   
   ## 进行中
   - [ ] [步骤 3] - 预计 [时间]
   
   ## 阻塞项
   - [问题]: [状态]
   ```

【工作流程】:
1. 用户提出复杂任务 → 创建 task_plan.md
2. 每完成一步 → 更新 task_plan.md 和 progress.md
3. 遇到重要发现 → 记录到 findings.md
4. 会话中断后恢复 → 读取三个文件，继续执行

【约束】:
- 复杂任务必须创建 task_plan.md
- 每完成一个步骤必须更新文档
- 会话恢复时优先读取规划文档
- 禁止在文档缺失时执行复杂任务

## Skill 16: Skill 创建器 (Skill Creator)
【触发方式】: 用户说"创建新 skill"、"添加 skill"、"/skill:create"、"自定义 skill"

【执行流程】:
1. **需求收集**:
   询问用户：
   - Skill 名称: [简短描述]
   - 触发方式: [关键词/指令]
   - 核心功能: [解决什么问题]
   - 输入: [需要什么信息]
   - 输出: [期望什么结果]

2. **生成 Skill 定义**:
   按照以下模板创建 Skill：
   ```markdown
   ## Skill [编号]: [名称]
   【触发方式】: [触发条件]
   
   【执行流程】:
   1. [步骤 1]
   2. [步骤 2]
   3. [步骤 3]
   
   【输出格式】:
   ```
   [输出模板]
   ```
   
   【约束】:
   - [约束 1]
   - [约束 2]
   ```

3. **集成到 .clinerules**:
   - 添加到 Skill 编排器的意图识别表
   - 更新使用说明中的核心 Skill 列表

4. **验证测试**:
   - 生成测试用例
   - 验证触发词是否有效

【Skill 设计原则】:
- 单一职责: 一个 Skill 只做一件事
- 明确触发: 清晰的触发条件和关键词
- 可重复: 相同输入产生一致输出
- 可验证: 有明确的完成标准

【输出格式】:
```
🎯 Skill 创建完成: [名称]

📋 Skill 定义:
[完整 Skill 定义]

🔗 集成位置:
- 添加到 Skill 0 意图识别表
- 更新使用说明

🧪 测试用例:
1. 输入: [测试输入] → 预期: [预期行为]
2. 输入: [测试输入] → 预期: [预期行为]

✅ 使用方法:
说"[触发词]"即可激活
```

【约束】:
- Skill 编号按顺序分配
- 触发词不能与现有 Skill 冲突
- 必须提供使用示例
- 必须定义明确的约束条件

---

## Skill 17: TDD 循环开发 (TDD Loop)
【触发方式】: 用户说"TDD 模式"、"循环开发"、"迭代开发"、"先写测试"、"红绿重构"

【核心循环】:
```
红阶段: 写测试 → 运行（应失败）
绿阶段: 最小实现 → 运行（应通过）
重构: 优化代码 → 运行（仍通过）
下一轮: 询问是否继续
```

【执行流程】:
1. **需求分析**: 分析功能点，预估测试用例数
2. **红阶段**: 仅编写测试代码，不实现功能
3. **绿阶段**: 编写最小代码使测试通过
4. **自动修复**: 测试失败时自动尝试修复（最多3次）
5. **重构**: 改进代码质量，保持测试通过
6. **迭代决策**: 显示完成状态，询问下一步

【快捷指令】:
- `/tdd` - 进入 TDD 模式
- `/tdd next` - 当前功能完成，进入下一个功能
- `/tdd fix` - 手动触发修复当前失败测试
- `/tdd stop` - 停止 TDD 循环

【约束】:
- 每轮只实现一个最小功能点
- 红阶段只写测试，不写实现
- 绿阶段只求通过，不求完美
- 重构阶段小步前进，频繁运行测试

---

## Skill 18: TDD 开发工作流 (TDD Dev)
【触发方式】: 用户说"/skill:tdd-dev" 或 "TDD开发"

【执行流程】:
1. `cost-control` - 建立 TDD 基线消耗
2. `tdd-loop` - 执行红-绿-重构自动化循环
3. `code-review` - TDD 完成后代码审查
4. `doc-system` - 更新 progress.txt
5. `git-commit` - 生成 commit (type: test/feat/refactor)
6. `cost-control` - TDD 总消耗统计

【特点】:
- 一键进入完整的 TDD 开发流程
- 自动执行成本控制和文档更新
- 支持中断和恢复

---

## Skill 19: Bug 修复工作流 (Bug Fix)
【触发方式】: 用户说"/skill:bug-fix"、"修复bug"、"debug"、"报错了"、"出错了"

【执行流程】:
1. `cost-control` - 记录修复前消耗
2. `debug-diagnosis` - 分析错误信息，定位根因，输出修复方案
3. `danger-signals` - 检查修复次数（防循环），第3次仍未解决→提示回滚
4. `code-review` - 审查修复代码，验证修复质量
5. `doc-system` - 记录问题到 progress.txt，更新技术债务区
6. `git-commit` - 生成 fix 类型 commit message
7. `cost-control` - Debug 成本统计

【防循环保护】:
- 第1次修复: 正常执行
- 第2次修复: 提示"如再次失败建议回滚"
- 第3次修复: 强制提示"已修复3次未解决，建议回滚到稳定版本"

---

## Skill 20: 代码提交工作流 (Code Submit)
【触发方式】: 用户说"/skill:code-submit"、"提交代码"、"commit"、"准备提交"

【执行流程】:
1. `cost-control` - 记录提交前消耗
2. `code-review` - 全面代码审查（可读性/性能/安全/类型检查）
3. `project-context` - 检查项目规范符合度，验证 KIMI.md 技术铁律
4. `doc-system` - 更新 progress.txt，标记待提交状态
5. `git-commit` - 分析改动内容，生成标准 commit message，提供 commit 命令
6. `cost-control` - 本次开发总消耗

【提交前检查清单】:
- ✅ Code Review: 可读性、错误处理、性能、安全、类型
- ✅ Project Context: 符合 KIMI.md 规范
- ✅ Documentation: progress.txt 已更新

---

## Skill 21: 设计稿还原工作流 (Design Restore)
【触发方式】: 用户说"/skill:design-restore"、"还原设计"、"设计稿"、"截图转代码"

【执行流程】:
1. `cost-control` - 预估还原成本
2. `visual-coding` - 结构分析（DOM树）、规范提取（配色/间距/字体）、组件拆分建议，保存 design-spec.md
3. `task-planner` - 制定组件实现计划，拆分 Header/Content/Sidebar 等，保存到 plan.md
4. 分组件实现（循环）- 组件1、组件2...每完成一个说"/cost"检查
5. `code-review` - 检查响应式/可访问性
6. `visual-coding` - 像素级对比验证
7. `doc-system` - 更新 progress.txt，记录设计规范到 KIMI.md
8. `git-commit` - 生成 feat 类型 commit
9. `cost-control` - UI开发成本总结

【设计规范输出】:
design-spec.md 包含：色彩规范、字体规范、间距规范、圆角/阴影等视觉 tokens

---

## Skill 22: 大文档整理工作流 (Doc Organize)
【触发方式】: 用户说"/skill:doc-organize"、"整理文档"、"处理文档"、"文档太大"

【执行流程】:
1. `cost-control` - 显示文档读取预估消耗，超过阈值时询问确认
2. `doc-processor` - 结构分析（输出文档地图）、分块方案（每块5k-8k字符）、等待用户发送第1块
3. 逐块处理（循环）- 块1、块2...显示"处理块 X/N，预估消耗: $x"
4. 累积检查 - 单轮 > $0.05 时强制询问"是否继续? [Y/N]"
5. `doc-processor`（整合）- 整合所有块摘要、去重处理、输出 final-document.md
6. `cost-control` - 文档处理总消耗

【快捷指令】:
- `/next` - 继续下一块
- "跳过" - 跳过当前块
- "整合" - 提前进入整合阶段

---

## Skill 23: 功能开发工作流 (Feature Dev)
【触发方式】: 用户说"/skill:feature-dev"、"开发新功能"、"功能开发"、"添加功能"

【执行流程】:
1. `cost-control` - 显示当前消耗，建立基线
2. `task-planner`（Plan Mode）- 分析需求，制定执行计划，保存计划到 plan.md，等待用户确认
3. `workflow` - 按 plan.md 逐步实现，每完成一步更新进度
4. `code-review` - 代码审查，输出审查报告
5. `doc-system` - 更新 progress.txt，更新 KIMI.md（如有规范变更）
6. `git-commit` - 生成 commit message
7. `cost-control` - 显示本轮开发总消耗

【使用方式】:
- 方式1：直接进入（已有明确需求）- 说"/skill:feature-dev"
- 方式2：带需求进入 - 说"我要添加用户登录功能"

---

## Skill 24: 项目健康度检查 (Health Check)
【触发方式】: 用户说"/skill:health-check"、"检查健康度"、"项目体检"

【执行流程】:
1. `cost-control` - 显示当前累计消耗，检查是否超过阈值 ($0.05 / $0.10)
2. `context-management` - 压缩上下文，保留关键信息，输出当前进度摘要
3. `danger-signals` - 检查危险信号（重复修复、大文件生成等），输出风险提示
4. `code-review` - 扫描最近修改的代码，输出健康度报告（测试/构建/类型检查）
5. `doc-system` - 更新 progress.txt，总结当前状态
6. `cost-control` - 输出本轮检查总消耗

---

## Skill 25: 新项目启动工作流 (New Project)
【触发方式】: 用户说"/skill:new-project"、"开始新项目"、"从零开始"、"启动新项目"

【执行流程】:
1. `cost-control` - 建立成本基线
2. `socratic-inquiry` - 苏格拉底式审问需求，澄清项目目标、范围、约束，输出需求确认清单
3. `task-planner` - 制定项目架构计划，技术选型建议，保存计划到 plan.md，等待用户确认
4. `doc-system` - 创建 KIMI.md（AI操作手册）、创建 progress.txt（进度追踪）、初始化项目文档结构
5. `workflow` - 按 plan.md 开始第一阶段开发
6. `cost-control` - 项目启动成本统计

【输出文档】:
- plan.md - 项目开发计划
- KIMI.md - AI 操作手册（技术规范、约束）
- progress.txt - 进度追踪

---

## Skill 26: 代码重构工作流 (Refactor Code)
【触发方式】: 用户说"/skill:refactor-code"、"重构代码"、"优化代码"、"重构这个模块"

【执行流程】:
1. `cost-control` - 建立重构成本基线
2. `code-review` - 分析目标模块，输出 ASCII 架构图，识别代码坏味道，输出问题清单
3. `task-planner` - 制定重构计划，依赖分析（底层→上层），分批策略（每批≤3文件），保存到 refactor-plan.md，等待用户确认
4. `code-refactor` - 按批次执行重构，每批展示 diff，保持函数签名兼容，每批后询问确认
5. `code-review` - 验证重构质量
6. `debug-diagnosis` - 自证重构未引入 bug
7. `doc-system` - 更新 progress.txt，记录技术债务清理
8. `git-commit` - 生成 refactor 类型 commit
9. `cost-control` - 重构成本对比

【安全原则】:
- 保持函数签名向后兼容
- 每次最多重构 3 个紧密关联的文件
- 修改前输出 diff 对比
- 建议先 `git add .` 再应用修改

---

## 使用说明

**保存位置**: 项目根目录 `ai-test-platform/.clinerules`

**立即测试**:
1. 保存文件后，**重启 Cline 对话**（点 + 号新建）
2. 引用你的大文件：`@Kimi_Code_Vibe_Coding_Guide.md 帮我整理`
3. 应该触发 **Skill 2**，显示分段提示而不是直接读取
4. 说"我要做一个新项目"应该触发 **Skill 8** 进入审问模式

**后续调整**:
- 如果某个 Skill 太敏感（频繁误触发），修改其【触发方式】描述，加更多关键词限制
- 如果规则太长导致 Cline 加载慢，可以删掉暂不需要的 Skill（如暂时不用 Skill 5 代码审查）
- 建议保留的核心 Skill: 1, 2, 8, 10, 12, 13
